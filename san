using Microsoft.AspNetCore.Mvc.Filters;
using Microsoft.AspNetCore.Mvc;
using System.Reflection;
using System.Collections; // Required for IEnumerable

public class XssEncodingActionFilter : IAsyncActionFilter
{
    private readonly IHtmlEncodingService _htmlEncodingService;

    public XssEncodingActionFilter(IHtmlEncodingService htmlEncodingService)
    {
        _htmlEncodingService = htmlEncodingService;
    }

    public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)
    {
        // This method executes BEFORE the action method.
        // Model binding has already occurred, so context.ActionArguments contains the bound models.

        foreach (var arg in context.ActionArguments.Values)
        {
            if (arg == null) continue;

            // Recursively process the argument to find and encode string properties
            EncodeStringProperties(arg);
        }

        // Continue to the action method
        await next();
    }

    /// <summary>
    /// Recursively HTML-encodes all public string properties of an object.
    /// Handles nested objects and collections.
    /// </summary>
    /// <param name="obj">The object whose string properties should be encoded.</param>
    /// <param name="visited">A set to track visited objects to prevent infinite loops with circular references.</param>
    private void EncodeStringProperties(object obj, HashSet<object> visited = null)
    {
        if (obj == null) return;

        // Initialize visited set for the top-level call
        visited ??= new HashSet<object>();

        // Check for circular references to prevent infinite loops
        if (visited.Contains(obj)) return;
        visited.Add(obj);

        var type = obj.GetType();

        // Handle collections (Lists, Arrays, etc.) but exclude strings themselves
        if (obj is IEnumerable enumerable && !(obj is string))
        {
            foreach (var item in enumerable)
            {
                // Only recurse for complex types within collections
                if (item != null && item.GetType().IsClass && item.GetType() != typeof(string))
                {
                    EncodeStringProperties(item, visited);
                }
                // String items in collections (e.g., List<string>) will be caught by the property iteration if they are properties of an enclosing object.
                // If the collection itself is directly bound (e.g., [FromBody] List<string>), you would need to handle that specifically
                // which is less common for complex sanitization scenarios typically targeting complex models.
            }
        }

        // Iterate through public instance properties of the current object
        foreach (var prop in type.GetProperties(BindingFlags.Public | BindingFlags.Instance))
        {
            if (prop.CanRead && prop.CanWrite) // Ensure property can be read and written to
            {
                if (prop.PropertyType == typeof(string))
                {
                    // It's a string property, get its value and encode it
                    try
                    {
                        var value = (string)prop.GetValue(obj);
                        if (!string.IsNullOrEmpty(value))
                        {
                            var encodedValue = _htmlEncodingService.EncodeHtml(value);
                            prop.SetValue(obj, encodedValue);
                        }
                    }
                    catch (Exception ex)
                    {
                        // Log errors without stopping execution, e.g., if a property cannot be accessed
                        Console.WriteLine($"Error encoding property '{prop.Name}' of type '{type.Name}': {ex.Message}");
                    }
                }
                else if (prop.PropertyType.IsClass && prop.PropertyType != typeof(string))
                {
                    // It's a complex object (not a string), recurse into it
                    var nestedObj = prop.GetValue(obj);
                    if (nestedObj != null)
                    {
                        EncodeStringProperties(nestedObj, visited);
                    }
                }
                // Primitive types (int, bool, etc.) don't need XSS encoding.
            }
        }
    }
}
